import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;

part 'database.g.dart';

// Table definitions
class Users extends Table {
  TextColumn get id => text()();
  TextColumn get email => text()();
  TextColumn get name => text()();
  DateTimeColumn get createdAt => dateTime()();

  @override
  Set<Column> get primaryKey => {id};
}

class Expenses extends Table {
  TextColumn get id => text()();
  TextColumn get userId => text().references(Users, #id)();
  RealColumn get amount => real()();
  TextColumn get category => text()();
  TextColumn get description => text()();
  DateTimeColumn get date => dateTime()();
  TextColumn get receiptImage => text().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

class Budgets extends Table {
  TextColumn get id => text()();
  TextColumn get userId => text().references(Users, #id)();
  TextColumn get category => text()();
  RealColumn get limit => real()();
  DateTimeColumn get periodStart => dateTime()();
  DateTimeColumn get periodEnd => dateTime()();

  @override
  Set<Column> get primaryKey => {id};
}

class Categories extends Table {
  TextColumn get id => text()();
  TextColumn get name => text()();
  TextColumn get icon => text()();
  TextColumn get color => text()();

  @override
  Set<Column> get primaryKey => {id};
}

// Data classes are automatically generated by Drift
// See database.g.dart for the generated classes

// Database class
@DriftDatabase(tables: [Users, Expenses, Budgets, Categories])
class FinancialDatabase extends _$FinancialDatabase {
  FinancialDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 1;

  // User operations
  Future<List<User>> getAllUsers() => select(users).get();

  Future<User?> getUserById(String id) =>
      (select(users)..where((u) => u.id.equals(id))).getSingleOrNull();

  Future<int> insertUser(UsersCompanion user) => into(users).insert(user);

  Future<bool> updateUser(UsersCompanion user) => update(users).replace(user);

  // Expense operations
  Future<List<Expense>> getAllExpenses() => select(expenses).get();

  Future<List<Expense>> getExpensesByUserId(String userId) =>
      (select(expenses)..where((e) => e.userId.equals(userId))).get();

  Future<List<Expense>> getExpensesByCategory(String category) =>
      (select(expenses)..where((e) => e.category.equals(category))).get();

  Future<List<Expense>> getExpensesByDateRange(DateTime start, DateTime end) =>
      (select(expenses)..where((e) => e.date.isBetweenValues(start, end)))
          .get();

  Future<Expense?> getExpenseById(String id) =>
      (select(expenses)..where((e) => e.id.equals(id))).getSingleOrNull();

  Future<int> insertExpense(ExpensesCompanion expense) =>
      into(expenses).insert(expense);

  Future<bool> updateExpense(ExpensesCompanion expense) =>
      update(expenses).replace(expense);

  Future<int> deleteExpense(String id) =>
      (delete(expenses)..where((e) => e.id.equals(id))).go();

  // Budget operations
  Future<List<Budget>> getAllBudgets() => select(budgets).get();

  Future<List<Budget>> getBudgetsByUserId(String userId) =>
      (select(budgets)..where((b) => b.userId.equals(userId))).get();

  Future<int> insertBudget(BudgetsCompanion budget) =>
      into(budgets).insert(budget);

  Future<bool> updateBudget(BudgetsCompanion budget) =>
      update(budgets).replace(budget);

  // Category operations
  Future<List<Category>> getAllCategories() => select(categories).get();

  Future<int> insertCategory(CategoriesCompanion category) =>
      into(categories).insert(category);

  // Analytics queries
  Future<double> getTotalExpensesByUser(String userId) async {
    final result =
        await (select(expenses)..where((e) => e.userId.equals(userId))).get();
    return result.fold<double>(0.0, (sum, expense) => sum + expense.amount);
  }

  Future<double> getTotalExpensesByCategory(String category) async {
    final result = await (select(expenses)
          ..where((e) => e.category.equals(category)))
        .get();
    return result.fold<double>(0.0, (sum, expense) => sum + expense.amount);
  }

  Future<double> getTotalExpensesByDateRange(
      DateTime start, DateTime end) async {
    final result = await (select(expenses)
          ..where((e) => e.date.isBetweenValues(start, end)))
        .get();
    return result.fold<double>(0.0, (sum, expense) => sum + expense.amount);
  }
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'financial_planner.db'));
    return NativeDatabase.createInBackground(file);
  });
}
