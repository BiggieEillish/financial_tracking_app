import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;

part 'database.g.dart';

// Table definitions
class Users extends Table {
  TextColumn get id => text()();
  TextColumn get email => text()();
  TextColumn get name => text()();
  DateTimeColumn get createdAt => dateTime()();

  @override
  Set<Column> get primaryKey => {id};
}

class ExpenseGroups extends Table {
  TextColumn get id => text()();
  TextColumn get userId => text().references(Users, #id)();
  DateTimeColumn get date => dateTime()();
  TextColumn get storeName => text().nullable()();
  TextColumn get receiptImage => text().nullable()();
  TextColumn get currency => text().withDefault(const Constant('MYR'))();
  TextColumn get notes => text().nullable()();
  DateTimeColumn get createdAt => dateTime()();

  @override
  Set<Column> get primaryKey => {id};
}

class ExpenseItems extends Table {
  TextColumn get id => text()();
  TextColumn get groupId => text().references(ExpenseGroups, #id)();
  RealColumn get amount => real()();
  TextColumn get category => text()();
  TextColumn get description => text()();
  IntColumn get quantity => integer().withDefault(const Constant(1))();

  @override
  Set<Column> get primaryKey => {id};
}

class Budgets extends Table {
  TextColumn get id => text()();
  TextColumn get userId => text().references(Users, #id)();
  TextColumn get category => text()();
  RealColumn get limit => real()();
  DateTimeColumn get periodStart => dateTime()();
  DateTimeColumn get periodEnd => dateTime()();

  @override
  Set<Column> get primaryKey => {id};
}

class Categories extends Table {
  TextColumn get id => text()();
  TextColumn get name => text()();
  TextColumn get icon => text()();
  TextColumn get color => text()();

  @override
  Set<Column> get primaryKey => {id};
}

class RecurringExpenses extends Table {
  TextColumn get id => text()();
  TextColumn get userId => text().references(Users, #id)();
  RealColumn get amount => real()();
  TextColumn get category => text()();
  TextColumn get description => text()();
  TextColumn get frequency => text()(); // 'daily', 'weekly', 'monthly', 'yearly'
  DateTimeColumn get startDate => dateTime()();
  DateTimeColumn get endDate => dateTime().nullable()();
  DateTimeColumn get nextDueDate => dateTime()();
  BoolColumn get isActive => boolean().withDefault(const Constant(true))();
  TextColumn get currency => text().withDefault(const Constant('MYR'))();

  @override
  Set<Column> get primaryKey => {id};
}

// Data classes are automatically generated by Drift
// See database.g.dart for the generated classes

// Database class
@DriftDatabase(tables: [Users, ExpenseGroups, ExpenseItems, Budgets, Categories, RecurringExpenses])
class FinancialDatabase extends _$FinancialDatabase {
  FinancialDatabase() : super(_openConnection());

  @override
  int get schemaVersion => 4;

  @override
  MigrationStrategy get migration => MigrationStrategy(
        onCreate: (Migrator m) => m.createAll(),
        onUpgrade: (Migrator m, int from, int to) async {
          if (from < 4) {
            // Drop old expenses table if it exists
            await m.issueCustomQuery('DROP TABLE IF EXISTS expenses');
            // Create new tables
            await m.createTable(expenseGroups);
            await m.createTable(expenseItems);
            if (from < 3) {
              await m.createTable(recurringExpenses);
            }
          }
        },
      );

  // User operations
  Future<List<User>> getAllUsers() => select(users).get();

  Future<User?> getUserById(String id) =>
      (select(users)..where((u) => u.id.equals(id))).getSingleOrNull();

  Future<int> insertUser(UsersCompanion user) => into(users).insert(user);

  Future<bool> updateUser(UsersCompanion user) => update(users).replace(user);

  // ExpenseGroup operations
  Future<List<ExpenseGroup>> getAllExpenseGroups() =>
      select(expenseGroups).get();

  Future<List<ExpenseGroup>> getExpenseGroupsByUserId(String userId) =>
      (select(expenseGroups)..where((g) => g.userId.equals(userId))).get();

  Future<List<ExpenseGroup>> getExpenseGroupsByDateRange(
          String userId, DateTime start, DateTime end) =>
      (select(expenseGroups)
            ..where((g) =>
                g.userId.equals(userId) &
                g.date.isBetweenValues(start, end)))
          .get();

  Future<ExpenseGroup?> getExpenseGroupById(String id) =>
      (select(expenseGroups)..where((g) => g.id.equals(id)))
          .getSingleOrNull();

  Future<int> insertExpenseGroup(ExpenseGroupsCompanion group) =>
      into(expenseGroups).insert(group);

  Future<bool> updateExpenseGroup(ExpenseGroupsCompanion group) =>
      update(expenseGroups).replace(group);

  Future<int> deleteExpenseGroup(String id) =>
      (delete(expenseGroups)..where((g) => g.id.equals(id))).go();

  // ExpenseItem operations
  Future<List<ExpenseItem>> getAllExpenseItems() =>
      select(expenseItems).get();

  Future<List<ExpenseItem>> getItemsForGroup(String groupId) =>
      (select(expenseItems)..where((i) => i.groupId.equals(groupId))).get();

  Future<int> insertExpenseItem(ExpenseItemsCompanion item) =>
      into(expenseItems).insert(item);

  Future<bool> updateExpenseItem(ExpenseItemsCompanion item) =>
      update(expenseItems).replace(item);

  Future<int> deleteExpenseItem(String id) =>
      (delete(expenseItems)..where((i) => i.id.equals(id))).go();

  Future<int> deleteItemsForGroup(String groupId) =>
      (delete(expenseItems)..where((i) => i.groupId.equals(groupId))).go();

  // Budget operations
  Future<List<Budget>> getAllBudgets() => select(budgets).get();

  Future<List<Budget>> getBudgetsByUserId(String userId) =>
      (select(budgets)..where((b) => b.userId.equals(userId))).get();

  Future<int> insertBudget(BudgetsCompanion budget) =>
      into(budgets).insert(budget);

  Future<bool> updateBudget(BudgetsCompanion budget) =>
      update(budgets).replace(budget);

  Future<int> deleteBudget(String id) =>
      (delete(budgets)..where((b) => b.id.equals(id))).go();

  // Category operations
  Future<List<Category>> getAllCategories() => select(categories).get();

  Future<int> insertCategory(CategoriesCompanion category) =>
      into(categories).insert(category);

  // RecurringExpense operations
  Future<List<RecurringExpense>> getRecurringExpensesByUserId(String userId) =>
      (select(recurringExpenses)..where((e) => e.userId.equals(userId))).get();

  Future<List<RecurringExpense>> getActiveRecurringExpenses(String userId) =>
      (select(recurringExpenses)
            ..where(
                (e) => e.userId.equals(userId) & e.isActive.equals(true)))
          .get();

  Future<List<RecurringExpense>> getDueRecurringExpenses(
          String userId, DateTime beforeDate) =>
      (select(recurringExpenses)
            ..where((e) =>
                e.userId.equals(userId) &
                e.isActive.equals(true) &
                e.nextDueDate.isSmallerOrEqualValue(beforeDate)))
          .get();

  Future<RecurringExpense?> getRecurringExpenseById(String id) =>
      (select(recurringExpenses)..where((e) => e.id.equals(id)))
          .getSingleOrNull();

  Future<int> insertRecurringExpense(RecurringExpensesCompanion expense) =>
      into(recurringExpenses).insert(expense);

  Future<bool> updateRecurringExpense(RecurringExpensesCompanion expense) =>
      update(recurringExpenses).replace(expense);

  Future<int> deleteRecurringExpense(String id) =>
      (delete(recurringExpenses)..where((e) => e.id.equals(id))).go();
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'financial_planner.db'));
    return NativeDatabase.createInBackground(file);
  });
}
